# CVE-2017-7533



#### 작성자 : 조제

## Diff

#### 

{% code title="include\\linux\\dcache.h" %}
```c
...
...
...
#ifdef CONFIG_64BIT
# define DNAME_INLINE_LEN 32 /* 192 bytes */
#else
# ifdef CONFIG_SMP
#  define DNAME_INLINE_LEN 36 /* 128 bytes */
# else
#  define DNAME_INLINE_LEN 40 /* 128 bytes */
# endif
#endif
...
...
+struct name_snapshot {
+    const char *name;
+    char inline_name[DNAME_INLINE_LEN];
+};
+void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);
+void release_dentry_name_snapshot(struct name_snapshot *);
...
```
{% endcode %}

{% code title="Replace from fsnotify\_oldname\_init to  take\_dentry\_name\_snapshot" %}
```c
/*
 * fsnotify_oldname_init - save off the old filename before we change it
 */
#if defined(CONFIG_FSNOTIFY)    /* notify helpers */
static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)
{
    return kstrdup(name, GFP_KERNEL);
}
#else    /* CONFIG_FSNOTIFY */
static inline const char *fsnotify_oldname_init(const unsigned char *name)
{
    return NULL;
}
#endif    /*  CONFIG_FSNOTIFY */
#endif    /* _LINUX_FS_NOTIFY_H */
/////////////////////////////////////////////////////////
void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)
{
    spin_lock(&dentry->d_lock);
    if (unlikely(dname_external(dentry))) {
        struct external_name *p = external_name(dentry);
        atomic_inc(&p->u.count);
        spin_unlock(&dentry->d_lock);
        name->name = p->name;
    } else {
        memcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);
        spin_unlock(&dentry->d_lock);
        name->name = name->inline_name;
    }
}
EXPORT_SYMBOL(take_dentry_name_snapshot);
```
{% endcode %}

{% code title="Replace from fsnotify\_oldname\_free to release\_dentry\_name\_snapshot" %}
```c
/*
 * fsnotify_oldname_free - free the name we got from fsnotify_oldname_init
 */
#if defined(CONFIG_FSNOTIFY)    /* notify helpers */
static inline void fsnotify_oldname_free(const unsigned char *old_name)
{
    kfree(old_name);
}
#else    /* CONFIG_FSNOTIFY */
static inline void fsnotify_oldname_free(const unsigned char *old_name)
{}
#endif    /*  CONFIG_FSNOTIFY */
#endif    /* _LINUX_FS_NOTIFY_H */
///////////////////////////////////////////////////////////////////////
void release_dentry_name_snapshot(struct name_snapshot *name)
{
    if (unlikely(name->name != name->inline_name)) {
        struct external_name *p;
        p = container_of(name->name, struct external_name, name[0]);
        if (unlikely(atomic_dec_and_test(&p->u.count)))
            kfree_rcu(p, u.head);
    }
}
EXPORT_SYMBOL(release_dentry_name_snapshot);
```
{% endcode %}

## Scenario

```text
  inotify_handle_event(.., file_name)
    strlen(file_name)  // file_name is "foobar"
    alloc_len += len + 1;
    event = kmalloc(alloc_len, GFP_KERNEL); // 7 bytes for the file_name

                               sys_rename()
                                 __d_move() [in fs/dcache.c]
                                   copy_name()
                                   // rename to "foobar_lol_kek_u_pwned"

    strcpy(event->name, file_name);
    // now file_name points to "foobar_lol_kek_u_pwned"
    // but there is a space only for "foobar\0"
    // the next slab or slab's *freelist is corrupted with user controlled data
```

## Reference

타겟 코드



[https://github.com/spotify/linux/blob/master/fs/notify/inotify/inotify\_fsnotify.c](https://github.com/spotify/linux/blob/master/fs/notify/inotify/inotify_fsnotify.c)

POC

[https://github.com/hardenedlinux/offensive\_poc/blob/master/CVE-2017-7533/exploit.c](https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-7533/exploit.c)

diff

[https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=49d31c2f389acfe83417083e1208422b4091cd9e](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=49d31c2f389acfe83417083e1208422b4091cd9e)

