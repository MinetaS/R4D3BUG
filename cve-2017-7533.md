# CVE-2017-7533



#### 작성자 : 조제진



## Description

```text
A race condition was found in Linux kernel present since v3.14-rc1 upto v4.12
including. The race happens between threads of inotify_handle_event() and
vfs_rename() while running the rename operation against the same file. The next
slab data or the slab's free list pointer can be corrupted with attacker-controlled
data as a result of the race.
```

## Difference

{% code title="include\\linux\\dcache.h" %}
```c
...
...
...
#ifdef CONFIG_64BIT
# define DNAME_INLINE_LEN 32 /* 192 bytes */
#else
# ifdef CONFIG_SMP
#  define DNAME_INLINE_LEN 36 /* 128 bytes */
# else
#  define DNAME_INLINE_LEN 40 /* 128 bytes */
# endif
#endif
...
...
+struct name_snapshot {
+    const char *name;
+    char inline_name[DNAME_INLINE_LEN];
+};
+void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);
+void release_dentry_name_snapshot(struct name_snapshot *);
...
```
{% endcode %}

{% code title="Replace from fsnotify\_oldname\_init to  take\_dentry\_name\_snapshot" %}
```c
/*
 * fsnotify_oldname_init - save off the old filename before we change it
 */
#if defined(CONFIG_FSNOTIFY)    /* notify helpers */
static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)
{
    return kstrdup(name, GFP_KERNEL);
}
#else    /* CONFIG_FSNOTIFY */
static inline const char *fsnotify_oldname_init(const unsigned char *name)
{
    return NULL;
}
#endif    /*  CONFIG_FSNOTIFY */
#endif    /* _LINUX_FS_NOTIFY_H */
/////////////////////////////////////////////////////////
void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)
{
    spin_lock(&dentry->d_lock);
    if (unlikely(dname_external(dentry))) {
        struct external_name *p = external_name(dentry);
        atomic_inc(&p->u.count);
        spin_unlock(&dentry->d_lock);
        name->name = p->name;
    } else {
        memcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);
        spin_unlock(&dentry->d_lock);
        name->name = name->inline_name;
    }
}
EXPORT_SYMBOL(take_dentry_name_snapshot);
```
{% endcode %}

{% code title="Replace from fsnotify\_oldname\_free to release\_dentry\_name\_snapshot" %}
```c
/*
 * fsnotify_oldname_free - free the name we got from fsnotify_oldname_init
 */
#if defined(CONFIG_FSNOTIFY)    /* notify helpers */
static inline void fsnotify_oldname_free(const unsigned char *old_name)
{
    kfree(old_name);
}
#else    /* CONFIG_FSNOTIFY */
static inline void fsnotify_oldname_free(const unsigned char *old_name)
{}
#endif    /*  CONFIG_FSNOTIFY */
#endif    /* _LINUX_FS_NOTIFY_H */
///////////////////////////////////////////////////////////////////////
void release_dentry_name_snapshot(struct name_snapshot *name)
{
    if (unlikely(name->name != name->inline_name)) {
        struct external_name *p;
        p = container_of(name->name, struct external_name, name[0]);
        if (unlikely(atomic_dec_and_test(&p->u.count)))
            kfree_rcu(p, u.head);
    }
}
EXPORT_SYMBOL(release_dentry_name_snapshot);
```
{% endcode %}

copy\_name &lt;- - \_\_d\_move &lt;-- d\_move &lt;-- vfs\_name &lt;-- sys\_name

{% tabs %}
{% tab title="copy\_name" %}
{% code title="fs/dcache.c" %}
```c
static void copy_name(struct dentry *dentry, struct dentry *target)
{
	struct external_name *old_name = NULL;
	if (unlikely(dname_external(dentry)))
		old_name = external_name(dentry);
	if (unlikely(dname_external(target))) {
		atomic_inc(&external_name(target)->u.count);
		dentry->d_name = target->d_name;
	} else {
		memcpy(dentry->d_iname, target->d_name.name,
				target->d_name.len + 1);
		dentry->d_name.name = dentry->d_iname;
		dentry->d_name.hash_len = target->d_name.hash_len;
	}
	if (old_name && likely(atomic_dec_and_test(&old_name->u.count)))
		kfree_rcu(old_name, u.head);
}
```
{% endcode %}
{% endtab %}

{% tab title="\_\_d\_move" %}
{% code title="fs/dcache.c" %}
```c
/*
 * When switching names, the actual string doesn't strictly have to
 * be preserved in the target - because we're dropping the target
 * anyway. As such, we can just do a simple memcpy() to copy over
 * the new name before we switch, unless we are going to rehash
 * it.  Note that if we *do* unhash the target, we are not allowed
 * to rehash it without giving it a new name/hash key - whether
 * we swap or overwrite the names here, resulting name won't match
 * the reality in filesystem; it's only there for d_path() purposes.
 * Note that all of this is happening under rename_lock, so the
 * any hash lookup seeing it in the middle of manipulations will
 * be discarded anyway.  So we do not care what happens to the hash
 * key in that case.
 */
/*
 * __d_move - move a dentry
 * @dentry: entry to move
 * @target: new dentry
 * @exchange: exchange the two dentries
 *
 * Update the dcache to reflect the move of a file name. Negative
 * dcache entries should not be moved in this way. Caller must hold
 * rename_lock, the i_mutex of the source and target directories,
 * and the sb->s_vfs_rename_mutex if they differ. See lock_rename().
 */
static void __d_move(struct dentry *dentry, struct dentry *target,
		     bool exchange)
{
	struct inode *dir = NULL;
	unsigned n;
	if (!dentry->d_inode)
		printk(KERN_WARNING "VFS: moving negative dcache entry\n");

	BUG_ON(d_ancestor(dentry, target));
	BUG_ON(d_ancestor(target, dentry));

	dentry_lock_for_move(dentry, target);
	if (unlikely(d_in_lookup(target))) {
		dir = target->d_parent->d_inode;
		n = start_dir_add(dir);
		__d_lookup_done(target);
	}

	write_seqcount_begin(&dentry->d_seq);
	write_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);

	/* unhash both */
	/* __d_drop does write_seqcount_barrier, but they're OK to nest. */
	__d_drop(dentry);
	__d_drop(target);

	/* Switch the names.. */
	if (exchange)
		swap_names(dentry, target);
	else
		copy_name(dentry, target);

	/* rehash in new place(s) */
	__d_rehash(dentry);
	if (exchange)
		__d_rehash(target);

	/* ... and switch them in the tree */
	if (IS_ROOT(dentry)) {
		/* splicing a tree */
		dentry->d_flags |= DCACHE_RCUACCESS;
		dentry->d_parent = target->d_parent;
		target->d_parent = target;
		list_del_init(&target->d_child);
		list_move(&dentry->d_child, &dentry->d_parent->d_subdirs);
	} else {
		/* swapping two dentries */
		swap(dentry->d_parent, target->d_parent);
		list_move(&target->d_child, &target->d_parent->d_subdirs);
		list_move(&dentry->d_child, &dentry->d_parent->d_subdirs);
		if (exchange)
			fsnotify_update_flags(target);
		fsnotify_update_flags(dentry);
	}

	write_seqcount_end(&target->d_seq);
	write_seqcount_end(&dentry->d_seq);

	if (dir)
		end_dir_add(dir, n);
	dentry_unlock_for_move(dentry, target);
}
```
{% endcode %}
{% endtab %}

{% tab title="d\_move" %}
{% code title="fs/dcache.c" %}
```c
/*
 * d_move - move a dentry
 * @dentry: entry to move
 * @target: new dentry
 *
 * Update the dcache to reflect the move of a file name. Negative
 * dcache entries should not be moved in this way. See the locking
 * requirements for __d_move.
 */
void d_move(struct dentry *dentry, struct dentry *target)
{
	write_seqlock(&rename_lock);
	__d_move(dentry, target, false);
	write_sequnlock(&rename_lock);
}
EXPORT_SYMBOL(d_move);
```
{% endcode %}
{% endtab %}

{% tab title="vfs\_name" %}
{% code title="ffs/namei.c" %}
```c
/**
 * vfs_rename - rename a filesystem object
 * @old_dir:	parent of source
 * @old_dentry:	source
 * @new_dir:	parent of destination
 * @new_dentry:	destination
 * @delegated_inode: returns an inode needing a delegation break
 * @flags:	rename flags
 *
 * The caller must hold multiple mutexes--see lock_rename()).
 *
 * If vfs_rename discovers a delegation in need of breaking at either
 * the source or destination, it will return -EWOULDBLOCK and return a
 * reference to the inode in delegated_inode.  The caller should then
 * break the delegation and retry.  Because breaking a delegation may
 * take a long time, the caller should drop all locks before doing
 * so.
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 *
 * The worst of all namespace operations - renaming directory. "Perverted"
 * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
 * Problems:
 *	a) we can get into loop creation.
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 *	   story.
 *	c) we have to lock _four_ objects - parents and victim (if it exists),
 *	   and source (if it is not a directory).
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
 *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 *	   move will be locked.  Thus we can rank directories by the tree
 *	   (ancestors first) and rank all non-directories after them.
 *	   That works since everybody except rename does "lock parent, lookup,
 *	   lock child" and rename is under ->s_vfs_rename_mutex.
 *	   HOWEVER, it relies on the assumption that any object with ->lookup()
 *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 *	   we'd better make sure that there's no link(2) for them.
 *	d) conversion from fhandle to dentry may come in the wrong moment - when
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
 *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 *	   ->i_mutex on parents, which works but leads to some truly excessive
 *	   locking].
 */
int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry,
	       struct inode **delegated_inode, unsigned int flags)
{
	int error;
	bool is_dir = d_is_dir(old_dentry);
	const unsigned char *old_name;
	struct inode *source = old_dentry->d_inode;
	struct inode *target = new_dentry->d_inode;
	bool new_is_dir = false;
	unsigned max_links = new_dir->i_sb->s_max_links;

	if (source == target)
		return 0;

	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!target) {
		error = may_create(new_dir, new_dentry);
	} else {
		new_is_dir = d_is_dir(new_dentry);

		if (!(flags & RENAME_EXCHANGE))
			error = may_delete(new_dir, new_dentry, is_dir);
		else
			error = may_delete(new_dir, new_dentry, new_is_dir);
	}
	if (error)
		return error;

	if (!old_dir->i_op->rename)
		return -EPERM;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		if (is_dir) {
			error = inode_permission(source, MAY_WRITE);
			if (error)
				return error;
		}
		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
			error = inode_permission(target, MAY_WRITE);
			if (error)
				return error;
		}
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
				      flags);
	if (error)
		return error;

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
	dget(new_dentry);
	if (!is_dir || (flags & RENAME_EXCHANGE))
		lock_two_nondirectories(source, target);
	else if (target)
		inode_lock(target);

	error = -EBUSY;
	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
		goto out;

	if (max_links && new_dir != old_dir) {
		error = -EMLINK;
		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
			goto out;
		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
		    old_dir->i_nlink >= max_links)
			goto out;
	}
	if (is_dir && !(flags & RENAME_EXCHANGE) && target)
		shrink_dcache_parent(new_dentry);
	if (!is_dir) {
		error = try_break_deleg(source, delegated_inode);
		if (error)
			goto out;
	}
	if (target && !new_is_dir) {
		error = try_break_deleg(target, delegated_inode);
		if (error)
			goto out;
	}
	error = old_dir->i_op->rename(old_dir, old_dentry,
				       new_dir, new_dentry, flags);
	if (error)
		goto out;

	if (!(flags & RENAME_EXCHANGE) && target) {
		if (is_dir)
			target->i_flags |= S_DEAD;
		dont_mount(new_dentry);
		detach_mounts(new_dentry);
	}
	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
		if (!(flags & RENAME_EXCHANGE))
			d_move(old_dentry, new_dentry);
		else
			d_exchange(old_dentry, new_dentry);
	}
out:
	if (!is_dir || (flags & RENAME_EXCHANGE))
		unlock_two_nondirectories(source, target);
	else if (target)
		inode_unlock(target);
	dput(new_dentry);
	if (!error) {
		fsnotify_move(old_dir, new_dir, old_name, is_dir,
			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
		if (flags & RENAME_EXCHANGE) {
			fsnotify_move(new_dir, old_dir, old_dentry->d_name.name,
				      new_is_dir, NULL, new_dentry);
		}
	}
	fsnotify_oldname_free(old_name);

	return error;
}
EXPORT_SYMBOL(vfs_rename);
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Scenario

```text
  CPU 1                        | CPU 2
  inotify_handle_event(.., file_name)
  strlen(file_name)  // file_name is "foobar"
  alloc_len += len + 1;        |
  event = kmalloc(alloc_len, GFP_KERNEL); // 7 bytes for the file_name
                               |
                               | sys_rename()
                               | __d_move() [in fs/dcache.c]
                               | copy_name()
                               | rename to "foobar_lol_kek_u_pwned"
                               |
  strcpy(event->name, file_name);
  // now file_name points to "foobar_lol_kek_u_pwned"
  // but there is a space only for "foobar\0"
  // the next slab or slab's *freelist is corrupted with user controlled data
```

## Reference

타겟 코드



[https://github.com/spotify/linux/blob/master/fs/notify/inotify/inotify\_fsnotify.c](https://github.com/spotify/linux/blob/master/fs/notify/inotify/inotify_fsnotify.c)

POC

[https://github.com/hardenedlinux/offensive\_poc/blob/master/CVE-2017-7533/exploit.c](https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-7533/exploit.c)

diff

[https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=49d31c2f389acfe83417083e1208422b4091cd9e](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=49d31c2f389acfe83417083e1208422b4091cd9e)

